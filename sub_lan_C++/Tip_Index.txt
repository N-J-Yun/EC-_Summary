
//항목 2
tip_C++_1 : 클래스 상수 선언 및 정의와 enum hack 사용법

//항목 3
tip_C++_2 : const 멤버 함수, const return 멤버 함수
tip_C++_3 : mutable 멤버 변수의 활용
tip_C++_4 : 비상수 버전 멤버 함수가 코드 중복을 피하기 위해 상수 버전을 호출하는 법

//항목 4
tip_C++_5 : 비지역 정적 객체의 초기화 문제 해결(Singleton Pattern)

//항목 6
tip_C++_6 : unique한 객체 생성을 위한 객체 복사 방지법

//항목 7
tip_C++_7 : virtual 멤버 함수를 가진 base 클래스의 소멸자는 virtual로 선언하자.

//항목 8
tip_C++_8 : 소멸자에서 발생할 수 있는 예외 처리법
 
//항목 9
tip_C++_9 : 생성자, 소멸자 내에서 가상함수를 호출하지 말자!

//항목 11
tip_C++_10 : 대입연산자 오버로딩에서는 자기대입을 반드시 고려하자(+Copy & Swap) 

//항목 12
tip_C++_11 : 복사함수를 구현할 때 모든 부분을 복사하자(특히 파생 클래스에서)

//항목 13
tip_C++_12 : RAII(자원 획득은 초기화)기법, 팩토리 함수

//항목 14
tip_C++_13 : 자원 관리 클래스에서의 복사 동작 구현

//항목 15
tip_C++_14 : 실제 자원을 사용해야하는 API를 위한 자원 관리 객체 -> 자원 변환법(암시적, 명시적)

//항목 17
tip_C++_15 : new로 생성한 객체를 저장하는 스마트 포인터는 별도로 선언하자!

//항목 18
tip_C++_16 : 인터페이스 사용자의 실수를 막기 위해 새로운 타입을 들여와 인터페이스를 강화하자!
tip_C++_17 : 인터페이스 사용자에게 자원 관리 작업을 떠넘기지 않도록 하자!

//항목 19* : 클래스 설계 전 고려사항(클래스 설계는 타입 설계다)

//항목 20* : 매개변수가 내장 타입이라면 pass by value, 사용자 정의 타입이라면 pass by reference가 효율이 좋다.

//항목 21
tip_C++_18 : 새로운 객체를 반환해야 하는 함수를 작성하는 법(공식)

//항목 22* : protected는 public과 거의 다를 게 없다.(protected로 된 데이터를 지우면 그 데이터를 사용한 파생 클래스는?)

//항목 23
tip_C++_19 : 같은 기능의 비멤버 비프렌드 함수가 멤버 함수보다 캡슐화 측면에서 좋다.
tip_C++_20 : 네임스페이스의 활용(분할 구현) 및 비멤버 비프렌드 함수의 확장성
tip_C++_21 : 표준 swap의 대체 - std::swap의 템플릿 특수화 버전

//항목 26
tip_C++_22 : 변수의 정의는 최대한 늦추자 + RAII

//항목 27
tip_C++_23 : 파생클래스에서 가상함수 구현을 위해 base class의 가상함수를 호출하는 법(Static_cast 안쓰는법)
tip_C++_24 : 파생클래스에만 있는 함수를 사용하려 할 때 dynamic_cast를 쓰지말고 구조를 바꾸자
tip_C++_25 : cascading(폭포식) dynamic_cast의 끔찍함 + 캐스팅은 엥간해선 쓰지 말자

//항목 28* : 어떤 객체의 내부요소(private)에 대한 핸들(참조자, 포인터, iterator)을 반환하는 것은 되도록 피하자.

//항목 29
tip_C++_26 : 예외 안전성을 가진 함수 제공 기법

//항목 30* : inline은 작고, 자주 호출되는 함수에 대해서만 하는 것으로 묶어두자.(일단 하지말고 나중에)

//항목 31
tip_C++_27 : Pimpl Idiom(핸들 클래스) 구현 (컴파일 의존성 줄이기)
tip_C++_28 : 인터페이스 클래스 구현 메커니즘 1 (컴파일 의존성 줄이기)

//항목 32* : public 상속의 의미는 "is-a"(...는 ...의 일종) 이며, 
			기본 클래스에 적용되는 모든 것들이 파생 클래스에 그대로 적용되어야 한다.         

//항목 33
tip_C++_29 : 파생 클래스가 가린 기본 클래스의 이름을 다시 볼 수 있게 하는 방법1(using 선언)
tip_C++_30 : 파생 클래스가 가린 기본 클래스의 이름을 다시 볼 수 있게 하는 방법2(전달 함수)

//항목 34
tip_C++_31 : 순수, 단순, 비가상 함수를 활용해 파생 클래스가 물려받았으면 하는 것을 정밀하게 지정하자.

//항목 35
tip_C++_32 : NVI 관용구(non-virtual interface) 가상 함수의 래퍼
tip_C++_33 : Strategy 패턴 응용(함수 포인터 활용)
tip_C++_34 : Functional 헤더의 Function 사용(함수호출성 개체 활용)
tip_C++_35 : 고전적인 Strategy 패턴 활용(작업을 수행하는 클래스 따로 생성)

//항목 36* : 상속받은 비가상 함수를 파생클래스에서 재정의 하지 말자(설계에 모순이 생기며 소멸자 호출이 이상해진다)

//항목 37
tip_C++_36 : 상속받은 가상함수의 default 매개변수 값은 절대로 재정의 하면 안된다.

//항목 39
tip_C++_37 : private 상속은 최대한 대안을 찾고 없으면 사용하자(public 상속과 객체 합성)

//항목 40* : 다중 상속은 모호성과 가상 상속 문제가 발생할 수 있기 때문에 최대한 고민하자.

