
//항목 2
tip_C++_1 : 클래스 상수 선언 및 정의와 enum hack 사용법

//항목 3
tip_C++_2 : const 멤버 함수, const return 멤버 함수
tip_C++_3 : mutable 멤버 변수의 활용
tip_C++_4 : 비상수 버전 멤버 함수가 코드 중복을 피하기 위해 상수 버전을 호출하는 법

//항목 4
tip_C++_5 : 비지역 정적 객체의 초기화 문제 해결(Singleton Pattern)

//항목 6
tip_C++_6 : unique한 객체 생성을 위한 객체 복사 방지법

//항목 7
tip_C++_7 : virtual 멤버 함수를 가진 base 클래스의 소멸자는 virtual로 선언하자.

//항목 8
tip_C++_8 : 소멸자에서 발생할 수 있는 예외 처리법
 
//항목 9
tip_C++_9 : 생성자, 소멸자 내에서 가상함수를 호출하지 말자!

//항목 11
tip_C++_10 : 대입연산자 오버로딩에서는 자기대입을 반드시 고려하자(+Copy & Swap) 

//항목 12
tip_C++_11 : 복사함수를 구현할 때 모든 부분을 복사하자(특히 파생 클래스에서)

//항목 13
tip_C++_12 : RAII(자원 획득은 초기화)기법, 팩토리 함수

//항목 14
tip_C++_13 : 자원 관리 클래스에서의 복사 동작 구현

//항목 15
tip_C++_14 : 실제 자원을 사용해야하는 API를 위한 자원 관리 객체 -> 자원 변환법(암시적, 명시적)

//항목 17
tip_C++_15 : new로 생성한 객체를 저장하는 스마트 포인터는 별도로 선언하자!

//항목 18
tip_C++_16 : 인터페이스 사용자의 실수를 막기 위해 새로운 타입을 들여와 인터페이스를 강화하자!
tip_C++_17 : 인터페이스 사용자에게 자원 관리 작업을 떠넘기지 않도록 하자!

//항목 19* : 클래스 설계 전 고려사항(클래스 설계는 타입 설계다)

//항목 20* : 매개변수가 내장 타입이라면 pass by value, 사용자 정의 타입이라면 pass by reference가 효율이 좋다.

//항목 21
tip_C++_18 : 새로운 객체를 반환해야 하는 함수를 작성하는 법(공식)

//항목 22* : protected는 public과 거의 다를 게 없다.(protected로 된 데이터를 지우면 그 데이터를 사용한 파생 클래스는?)

//항목 23
tip_C++_19 : 같은 기능의 비멤버 비프렌드 함수가 멤버 함수보다 캡슐화 측면에서 좋다.
tip_C++_20 : 네임스페이스의 활용(분할 구현) 및 비멤버 비프렌드 함수의 확장성
tip_C++_21 : 표준 swap의 대체 - std::swap의 템플릿 특수화 버전

//항목 26
tip_C++_22 : 변수의 정의는 최대한 늦추자 + RAII


