//---------------------------------라이브러리 파일--------------------------------
class FileSystem											// 객체 사이즈가 굉장히 큰 클래스
{
public:
	// ...
	std::size_t numDisks() const;							// 많은 멤버 함수들 중 하나
	// ...
};

extern FileSystem tfs;										// 사용자가 쓰게 될 객체(초기화 되지 않은 외부변수)

// 해결책
// FileSystem& tfs()										// tfs객체를 이 함수로 대신한다.
// {														
// 	static FileSystem fs;									// 함수 내부에서 static 선언을 했다.(지역 정적 객체를 정의하고 초기화한다.)
// 	return fs;												// 이 객체에 대한 참조자를 반환하여 사용할 수 있게 한다.
// }

//-------------------------------------------------------------------------------

// 정적 객체(static object) - 데이터 영역에 저장되는 객체, 생성된 후부터 프로그램 종료까지 살아있는 객체
// 1. 전역 객체 
// 2. 네임스페이스 유효범위에서 정의된 객체
// 3. 클래스 안에서 static으로 선언된 객체
// 4. 함수 안에서 static으로 선언된 객체
// 5. 파일 유효범위에서 static으로 정의된 객체

// 위 다섯 종류의 정적 객체 중 함수 안에 있는 정적 객체는 지역 정적 객체(local static object)이며,
// 그 외는 비지역 정적 객체(non-local static object)이다.

// 그리고 컴파일러가 obj 파일을 만드는 과정에서 링커는 비지역 정적 객체의 초기화 순서를 정의하지 않는다.
// -> 초기화되지 않은 비지역 정적 객체를 다른 비지역 정적 객체가 사용한다면?? == disaster

// 따라서 우리는 Singleton pattern을 사용하여 비지역 정적 객체를 지역 정적 객체로 만들어 준다!
// -> 지역 정적 객체는 함수 호출 중에 그 객체의 정의에 최초로 닿았을 때(사용됐을 때) 초기화된다! == safe.

//---------------------------------사용자 정의 파일--------------------------------
class Directory
{
public:
	Directory(params);
	// ...
};

Directory::Directory(params)
{
	// ...
	std::size_t disks = tfs.numDisks();							// tfs 객체를 여기서 사용한다.
																// 만약 tfs 객체가 초기화되지 않았다면?
	// ...

	//std::size_t disks = tfs().numDisks();						// tfs가 tfs()로 바뀐 것 외엔 변화가 필요없다.
}

Directory tempDir(params);										// tfs와 다른 파일에서 정의된 비지역 정적 객체(전역 변수)
																// 만약 tfs가 tempDir보다 먼저 초기화되지 않았다면?? == disaster

// Directory& tempDir()											// tempDir 역시 비지역 정적 객체이기 때문에 singleton pattern을 사용한다.
// {												
// 	static Directory td;										// 지역 정적 객체를 정의/초기화하고
// 	return td;													// 참조자를 반환하여 사용할 수 있게 한다.
// }

//-------------------------------------------------------------------------------
